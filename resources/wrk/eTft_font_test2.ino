#include <TFT_eSPI.h>
#include <Fonts/Custom/orbitron_light_11_2.h>
#include <Fonts/Custom/orbitron_light_8.h>
  
#define CF_OL24 &Orbitron_Light_24
#define CF_OL32 &Orbitron_Light_32

#define CF_ORB &orbitron_light11pt7b
#define CF_ORB8 &orbitron_light8pt7b


#define TFT_CS   PIN_D8  // Chip select control pin D8
#define TFT_DC   PIN_D4  // Data Command control pin
#define TFT_RST  -1  // Reset pin (could connect to NodeMCU RST, see next line)
#define TOUCH_CS PIN_D2     // Chip select pin (T_CS) of touch screen


#define COLOR1 0x18C3
#define COLOR2 0x10A2

#define BUFF_SIZE 64

uint16_t colorPalette16[16];


// 24 * 18
const  uint8_t  wifi4 [] = {
0x00, 0x00, 0x00, 0x00, 0x24, 0x57, 0x75, 0x42, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x02, 0x6c, 0xff, 0xff, 0xff, 0xff, 0xc6, 0x20, 0x00, 0x00, 
0x00, 0x00, 0x6f, 0xff, 0xb6, 0x54, 0x45, 0x6b, 0xff, 0xf6, 0x00, 0x00, 
0x00, 0x3c, 0xff, 0x62, 0x00, 0x00, 0x00, 0x00, 0x26, 0xff, 0xc3, 0x00, 
0x03, 0xff, 0x81, 0x00, 0x00, 0x12, 0x21, 0x00, 0x00, 0x18, 0xff, 0x30, 
0x4f, 0xf5, 0x00, 0x02, 0x7e, 0xff, 0xff, 0xe7, 0x20, 0x00, 0x5f, 0xf4, 
0xaf, 0x50, 0x01, 0x8f, 0xff, 0xfb, 0xbf, 0xff, 0xf8, 0x10, 0x05, 0xfa, 
0x12, 0x00, 0x2d, 0xfe, 0x52, 0x10, 0x01, 0x25, 0xef, 0xd2, 0x00, 0x21, 
0x00, 0x02, 0xef, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xfe, 0x20, 0x00, 
0x00, 0x04, 0xf7, 0x00, 0x03, 0x6a, 0xa6, 0x30, 0x00, 0x7f, 0x40, 0x00, 
0x00, 0x00, 0x10, 0x00, 0x8f, 0xff, 0xff, 0xf8, 0x00, 0x01, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0b, 0xfb, 0x42, 0x24, 0xbf, 0xb0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0d, 0x81, 0x00, 0x00, 0x18, 0xd0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 20 * 18
const  uint8_t  clock4 [] = {
0x00, 0x00, 0x00, 0x25, 0x9c, 0xc9, 0x52, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x17, 0xff, 0xff, 0xff, 0xff, 0x71, 0x00, 0x00,  
0x00, 0x01, 0xbf, 0xa4, 0x10, 0x01, 0x4a, 0xfb, 0x10, 0x00,  
0x00, 0x1b, 0xf6, 0x00, 0x07, 0x70, 0x00, 0x6f, 0xb1, 0x00,  
0x00, 0x7f, 0x60, 0x00, 0x0f, 0xf0, 0x00, 0x06, 0xf7, 0x00, 
0x02, 0xfa, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0xaf, 0x20,  
0x05, 0xf4, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x4f, 0x50, 
0x09, 0xf1, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x1f, 0x90, 
0x0b, 0xf0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x70, 0x0f, 0xb0, 
0x0b, 0xf0, 0x00, 0x00, 0x07, 0xff, 0xff, 0x70, 0x0f, 0xb0, 
0x09, 0xf1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 
0x05, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x50,  
0x02, 0xfa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x20,  
0x00, 0x7f, 0x60, 0x00, 0x00, 0x00, 0x00, 0x06, 0xf7, 0x00, 
0x00, 0x1b, 0xf6, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xb1, 0x00,  
0x00, 0x01, 0xbf, 0xb4, 0x10, 0x01, 0x4b, 0xfb, 0x10, 0x00,  
0x00, 0x00, 0x17, 0xff, 0xff, 0xff, 0xff, 0x71, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x25, 0x8c, 0xc8, 0x52, 0x00, 0x00, 0x00 
};

// 12 * 20
const  uint8_t  thermo4 [] = {
0x00, 0x00, 0x28, 0xc8, 0x20, 0x00, 
0x00, 0x02, 0xff, 0xff, 0xf2, 0x00,
0x00, 0x08, 0xf3, 0x04, 0xf8, 0x00, 
0x00, 0x0d, 0xf0, 0x00, 0xfd, 0x00, 
0x00, 0x0f, 0xf0, 0x00, 0xff, 0x00,
0x00, 0x0f, 0xf0, 0x00, 0xff, 0x00, 
0x00, 0x0f, 0xf0, 0x00, 0xff, 0x00, 
0x00, 0x0f, 0xf0, 0x90, 0xff, 0x00, 
0x00, 0x0f, 0xf0, 0xf0, 0xff, 0x00, 
0x00, 0x0f, 0xf0, 0xf0, 0xff, 0x00, 
0x00, 0x0f, 0xf0, 0xf0, 0xff, 0x00, 
0x00, 0x0f, 0xf0, 0xf0, 0xff, 0x00, 
0x00, 0x7f, 0x70, 0xf0, 0x7f, 0x70,  
0x01, 0xfa, 0x06, 0xf6, 0x0a, 0xf1, 
0x03, 0xf5, 0x3f, 0xff, 0x35, 0xf3,  
0x03, 0xf5, 0x3f, 0xff, 0x35, 0xf3, 
0x01, 0xfa, 0x06, 0xc6, 0x0a, 0xf1, 
0x00, 0x8f, 0x81, 0x01, 0x8f, 0x80, 
0x00, 0x19, 0xff, 0xff, 0xf9, 0x10,  
0x00, 0x00, 0x49, 0xd9, 0x40, 0x00 
};

// 22 * 16
const  uint8_t  cloudUp4 [] = {
0x00, 0x00, 0x00, 0x02, 0x6b, 0xc8, 0x40, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x6f, 0xff, 0xff, 0xfc, 0x20, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x07, 0xff, 0x51, 0x01, 0x5e, 0xd2, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3f, 0xf3, 0x00, 0x00, 0x03, 0xfa, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x9f, 0xe9, 0x40, 0x00,  
0x00, 0x00, 0xbf, 0x40, 0x00, 0x00, 0x00, 0x4f, 0xff, 0xf9, 0x10, 
0x00, 0x04, 0xff, 0x40, 0x00, 0x06, 0x00, 0x11, 0x01, 0x8f, 0x80, 
0x00, 0x6f, 0xff, 0x70, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x0a, 0xf1, 
0x02, 0xfc, 0x20, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x05, 0xf3, 
0x05, 0xf5, 0x00, 0x00, 0xff, 0x0f, 0x0f, 0xf0, 0x00, 0x05, 0xf3, 
0x06, 0xf5, 0x00, 0x00, 0x60, 0x0f, 0x00, 0x60, 0x00, 0x0a, 0xf1,
0x03, 0xfd, 0x20, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x01, 0x8f, 0x80, 
0x00, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x10,
0x00, 0x03, 0x9e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe9, 0x40, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 22 * 14
const  uint8_t  cloudDown4 [] = {
0x00, 0x00, 0x00, 0x02, 0x6b, 0xc8, 0x40, 0x00, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x6f, 0xff, 0xff, 0xfc, 0x20, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x07, 0xff, 0x51, 0x01, 0x5e, 0xd2, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x3f, 0xf3, 0x00, 0x00, 0x03, 0xfa, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x7f, 0x80, 0x00, 0x06, 0x00, 0x9f, 0xe9, 0x40, 0x00,  
0x00, 0x00, 0xbf, 0x40, 0x00, 0x0f, 0x00, 0x4f, 0xff, 0xf9, 0x10,  
0x00, 0x04, 0xff, 0x40, 0x00, 0x0f, 0x00, 0x11, 0x01, 0x8f, 0x80,  
0x00, 0x6f, 0xff, 0x70, 0x60, 0x0f, 0x00, 0x60, 0x00, 0x0a, 0xf1,  
0x02, 0xfc, 0x20, 0x00, 0xff, 0x0f, 0x0f, 0xf0, 0x00, 0x05, 0xf3,  
0x05, 0xf5, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x05, 0xf3,  
0x06, 0xf5, 0x00, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x0a, 0xf1,  
0x03, 0xfd, 0x20, 0x00, 0x00, 0x06, 0x00, 0x00, 0x01, 0x8f, 0x80,  
0x00, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x10,  
0x00, 0x03, 0x9e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe9, 0x40, 0x00
};

// 20 * 20
const  uint8_t  radio4 [] = {
0x00, 0x9f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf9, 0x00,  
0x04, 0xf5, 0x02, 0x20, 0x00, 0x00, 0x02, 0x20, 0x5f, 0x40, 
0x1e, 0x90, 0x1e, 0x70, 0x00, 0x00, 0x07, 0xe1, 0x09, 0xe1, 
0x3f, 0x20, 0x8f, 0x10, 0x00, 0x00, 0x02, 0xf8, 0x03, 0xf3, 
0x5f, 0x11, 0xf5, 0x00, 0x27, 0x71, 0x00, 0x6f, 0x11, 0xf5, 
0x8c, 0x03, 0xf3, 0x00, 0xbf, 0xfa, 0x00, 0x3f, 0x30, 0xc8, 
0xa9, 0x04, 0xf2, 0x01, 0xff, 0xff, 0x10, 0x2f, 0x40, 0x9a,  
0x7e, 0x02, 0xf3, 0x00, 0x7f, 0xf7, 0x00, 0x3f, 0x20, 0xf7,  
0x4f, 0x11, 0xf8, 0x00, 0x03, 0x30, 0x00, 0x8f, 0x01, 0xf4, 
0x2f, 0x40, 0x5f, 0x30, 0x03, 0x30, 0x03, 0xf5, 0x04, 0xf2,  
0x0a, 0xd1, 0x0a, 0x70, 0x0d, 0xd0, 0x07, 0xa0, 0x1c, 0xa0, 
0x02, 0xf8, 0x00, 0x00, 0x3f, 0xf3, 0x00, 0x00, 0x8f, 0x20, 
0x00, 0x5f, 0x20, 0x00, 0x6f, 0xf6, 0x00, 0x02, 0xf6, 0x00,  
0x00, 0x04, 0x00, 0x00, 0xd9, 0x9d, 0x00, 0x00, 0x40, 0x00,  
0x00, 0x00, 0x00, 0x02, 0xf4, 0x4f, 0x20, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x06, 0xf7, 0x7f, 0x60, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x0c, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0f, 0x50, 0x05, 0xf0, 0x00, 0x00, 0x00,  
0x00, 0x00, 0x00, 0x2f, 0x10, 0x01, 0xf2, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00
};

TFT_eSPI tft = TFT_eSPI();  

void setup() {
  Serial.begin(115200);

  uint8_t bx;
  uint8_t by;


  uint8_t bw = 120;
  uint8_t bh = 98;
  
  uint8_t b1x = 0;
  uint8_t b1y = 124;

  uint8_t b2x = b1x+bw;
  uint8_t b2y = b1y;

  uint8_t b3x = b1x;
  uint8_t b3y = b1y+bh;

  uint8_t b4x = b1x+bw;
  uint8_t b4y = b1y+bh;  
  


  tft.begin();
  tft.setRotation(0);

  tft.fillScreen(TFT_BLACK);

//  tft.setTextColor(TFT_DARKGREY,TFT_BLACK);



  tft.fillRect(0,  0, 240, 24, COLOR1);

//tft.pushImage(10, 50, 24, 24, wifi );

//drawIcon(clock, 10, 40, 24, 24);
//drawIcon4(clock4, 10, 65, 24, 24, TFT_WHITE, TFT_BLACK);

int iconX = 4;

/*
783     557
687     500
678     500
683     500
673     499
673     499


442
352
219
335
312
274


 */
Serial.println("=======================");
//generateColorPalette16(colorPalette16,  TFT_DARKGREY, COLOR1);
generateColorPalette16(colorPalette16,  TFT_GREEN, COLOR1);
Serial.println("======================="); 

  
drawIcon4Fast(wifi4, iconX, 3, 24, 18, colorPalette16);
iconX = iconX + 28;
drawIcon4Fast(radio4, iconX+2, 2, 20, 20, colorPalette16);
iconX = iconX + 28;
yield();
drawIcon4Fast(thermo4, iconX, 2, 12, 20, colorPalette16);
iconX = iconX + 16;
yield();
drawIcon4Fast(clock4, iconX+2, 4, 20, 18, colorPalette16);
iconX = iconX + 28;
yield();
drawIcon4Fast(cloudUp4, iconX, 5, 22, 16, colorPalette16);
iconX = iconX + 28;
yield();
drawIcon4Fast(cloudDown4, iconX, 5, 22, 14, colorPalette16);
iconX = iconX + 28;
yield();
  tft.fillRect(b1x,  b1y, bw, bh, COLOR1);
  tft.fillRect(b2x,  b2y, bw, bh, COLOR2);
  tft.fillRect(b3x,  b3y, bw, bh, COLOR2);
  tft.fillRect(b4x,  b4y, bw, bh, COLOR1);

  tft.setTextColor(TFT_DARKGREY,COLOR1);
  tft.setTextDatum(MR_DATUM); 
  tft.drawString("4.41V", 237, 11, 2);


  // clock
  tft.setTextColor(TFT_GREEN,TFT_BLACK);
  tft.setTextDatum(MC_DATUM);  
  tft.drawString("15:30", 120, 60, 7);

  tft.setFreeFont(CF_ORB);
//  tft.drawString("2018.10.29", 120, 100, 1);
  


  tft.setTextColor(TFT_DARKGREY,TFT_BLACK);
  tft.setTextDatum(ML_DATUM);
  tft.drawString("09.10", 4, 100, 1);
  tft.setTextDatum(MR_DATUM);
  tft.drawString("sun", 237, 100, 1);

/*B1********************************************************/  
  bx = b1x;
  by = b1y;
  
  tft.setTextColor(TFT_DARKGREY,COLOR1);
  tft.setTextDatum(ML_DATUM);
  tft.drawString("livingroom", bx+4, by+10, 2);
  
  tft.setTextDatum(MC_DATUM);  
  tft.setTextColor(TFT_GREEN,COLOR1);
  tft.setFreeFont(CF_OL32);
  tft.drawString("20.1", bx+60, by+35, 1);
 // tft.setFreeFont(CF_OL24);
  tft.setFreeFont(CF_ORB);

  tft.drawString("37.0", bx+60, by+70, 1);

/*B2********************************************************/  
  bx = b2x;
  by = b2y;

  tft.setTextColor(TFT_DARKGREY,COLOR2);
  tft.setTextDatum(ML_DATUM);
  tft.drawString("child's room", bx+4, by+10, 2);
  
  tft.setTextDatum(MC_DATUM);  
  tft.setTextColor(TFT_GREEN,COLOR2);  
  tft.setFreeFont(CF_OL32);
  tft.drawString("21.1", bx+60, by+35, 1);
  //tft.setFreeFont(CF_OL24);
  tft.setFreeFont(CF_ORB);

  tft.drawString("56.8", bx+60, by+70, 1);

/*B3********************************************************/  
  bx = b3x;
  by = b3y;

  tft.setTextColor(TFT_DARKGREY,COLOR2);
  tft.setTextDatum(ML_DATUM);
  tft.drawString("outdoor", bx+4, by+10, 2);
  
  tft.setTextDatum(MC_DATUM);  
  tft.setTextColor(TFT_GREEN,COLOR2);
  tft.setFreeFont(CF_OL32);
  tft.drawString("-5.5", bx+60, by+35, 1);
  tft.setFreeFont(CF_OL24);
  tft.drawString("13.8", bx+60, by+70, 1);

/*B4********************************************************/ 
  bx = b4x;
  by = b4y;

  tft.setTextColor(TFT_DARKGREY,COLOR1);
  tft.setTextDatum(ML_DATUM);
  tft.drawString("atm.pressure", bx+4, by+10, 2);
  
  tft.setTextDatum(MC_DATUM);
  tft.setTextColor(TFT_GREEN,COLOR1);
  tft.setFreeFont(CF_OL24);
  tft.drawString("1015", bx+60, by+34, 1);

  int xd = 144;
  int dBottom =  310;
  int dh = 30;
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 30;
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 28;
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 26;  
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 22;  
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 12;  
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 4;  
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 10;  
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 18;  
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);
  xd += 8;
  dh = 24;  
  tft.fillRect(xd,dBottom-dh,4,dh,TFT_DARKGREY);

}

void loop() {
  // put your main code here, to run repeatedly:

}


void drawIcon(const unsigned short* icon, int16_t x, int16_t y, uint16_t width, uint16_t height) {

  uint16_t  pix_buffer[BUFF_SIZE];   // Pixel buffer (16 bits per pixel)

  // Set up a window the right size to stream pixels into
  tft.setWindow(x, y, x + width - 1, y + height - 1);

  // Work out the number whole buffers to send
  uint16_t nb = ((uint16_t)height * width) / BUFF_SIZE;

  // Fill and send "nb" buffers to TFT
  for (int i = 0; i < nb; i++) {
    for (int j = 0; j < BUFF_SIZE; j++) {
      pix_buffer[j] = pgm_read_word(&icon[i * BUFF_SIZE + j]);
    }
    tft.pushColors(pix_buffer, BUFF_SIZE);
  }

  // Work out number of pixels not yet sent
  uint16_t np = ((uint16_t)height * width) % BUFF_SIZE;

  // Send any partial buffer left over
  if (np) {
    for (int i = 0; i < np; i++) pix_buffer[i] = pgm_read_word(&icon[nb * BUFF_SIZE + i]);
    tft.pushColors(pix_buffer, np);
  }
}


void drawIcon8(const uint8_t icon[], int16_t x, int16_t y, uint16_t width, uint16_t height, uint16_t fgColor, uint16_t bgColor ) {
  unsigned long mill = millis();
  tft.setWindow(x, y, x + width - 1, y + height - 1);
  uint16_t arraySize = ((uint16_t)width * height);
  for (int i = 0; i < arraySize; i++) {
    tft.pushColor(alphaBlend(icon[i], fgColor, bgColor));
  }
  Serial.println(millis()-mill);
}


void drawIcon4(const uint8_t icon[], int16_t x, int16_t y, uint16_t width, uint16_t height, uint16_t fgColor, uint16_t bgColor ) {
  unsigned long micro = micros();  
  tft.setWindow(x, y, x + width - 1, y + height - 1);

  uint16_t arraySize = width * height / 2;
  uint8_t alpha;
  
  for (int i = 0; i < arraySize; i++) {
    alpha = icon[i] & 0xF0;  
    tft.pushColor(alphaBlend(alpha, fgColor, bgColor));
    alpha = icon[i]<<4;  
    tft.pushColor(alphaBlend(alpha, fgColor, bgColor));
  }
  Serial.println(micros()-micro);  
}

/*
void drawIcon4Fast(const uint8_t icon[], int16_t x, int16_t y, uint16_t width, uint16_t height, uint16_t fgColor, uint16_t bgColor ) {
  unsigned long micro = micros();   

  uint16_t fgR = ((fgColor >> 10) & 0x3E) + 1;
  uint16_t fgG = ((fgColor >>  4) & 0x7E) + 1;
  uint16_t fgB = ((fgColor <<  1) & 0x3E) + 1;

  uint16_t bgR = ((bgColor >> 10) & 0x3E) + 1;
  uint16_t bgG = ((bgColor >>  4) & 0x7E) + 1;
  uint16_t bgB = ((bgColor <<  1) & 0x3E) + 1;

  tft.setWindow(x, y, x + width - 1, y + height - 1);

  uint16_t arraySize = width * height / 2;
  uint8_t alpha;
  uint16_t destColor;
  
  for (int i = 0; i < arraySize; i++) {
    for (int8_t step = 1; step < 3; step++){
      if(step == 1){
        alpha = icon[i] & 0xF0;
      }
      else{
        alpha = icon[i]<<4;
      }
      switch(alpha){
        case 0:
          destColor = bgColor;
          break;
        case 240:
          destColor = fgColor;
          break;
        default:
          uint16_t r = (((fgR * alpha) + (bgR * (255 - alpha))) >> 9);
          uint16_t g = (((fgG * alpha) + (bgG * (255 - alpha))) >> 9);
          uint16_t b = (((fgB * alpha) + (bgB * (255 - alpha))) >> 9);
          destColor = (r << 11) | (g << 5) | (b << 0); 
      }  
      tft.pushColor(destColor);
    }  
  }
  Serial.println(micros()-micro);  
}
*/
void generateColorPalette16(uint16_t *colorPalette,  uint16_t fgColor, uint16_t bgColor){
  unsigned long micro = micros();     
  uint16_t fgR = ((fgColor >> 10) & 0x3E) + 1;
  uint16_t fgG = ((fgColor >>  4) & 0x7E) + 1;
  uint16_t fgB = ((fgColor <<  1) & 0x3E) + 1;

  uint16_t bgR = ((bgColor >> 10) & 0x3E) + 1;
  uint16_t bgG = ((bgColor >>  4) & 0x7E) + 1;
  uint16_t bgB = ((bgColor <<  1) & 0x3E) + 1;

  //uint8_t alpha; 

  colorPalette[0] = bgColor;
  for(uint8_t i = 1; i < 15; i++){
    //alpha = i * 16;
    uint16_t r = (((fgR * i * 16) + (bgR * (255 - (i * 16)))) >> 9);
    uint16_t g = (((fgG * i * 16) + (bgG * (255 - (i * 16)))) >> 9);
    uint16_t b = (((fgB * i * 16) + (bgB * (255 - (i * 16)))) >> 9);
    colorPalette[i] = (r << 11) | (g << 5) | (b << 0);        
  }
   colorPalette[15] = fgColor;

   Serial.println(micros()-micro); 
}


void drawIcon4Fast(const uint8_t icon[], int16_t x, int16_t y, uint16_t width, uint16_t height, uint16_t *colorPalette) {
  unsigned long micro = micros();

  tft.setWindow(x, y, x + width - 1, y + height - 1);
  uint16_t  writeBuffer[64];   
  uint8_t  buffers = (width * height) / 64;
  
  for (int i = 0; i < buffers; i++) {
    for (int j = 0; j < 32; j++) {
      writeBuffer[j*2] = colorPalette[icon[i * 32 + j] >> 4];
      writeBuffer[(j*2)+1] = colorPalette[icon[i * 32 + j] & 0x0F]; 
    }
    tft.pushColors(writeBuffer, 64);   
  }

  uint8_t restBytes = ((height * width) % 64)/2;
  if (restBytes) {
    for (int i = 0; i < restBytes; i++){
      writeBuffer[i*2] = colorPalette[icon[buffers * 32 + i] >> 4];
      writeBuffer[(i*2)+1] = colorPalette[icon[buffers * 32 + i] & 0x0F];
    }
    tft.pushColors(writeBuffer, restBytes*2);
  }
 
 Serial.println(micros()-micro);   
}


void drawIcon4uFast(const uint8_t icon[], int16_t x, int16_t y, uint16_t width, uint16_t height, uint16_t *colorPalette) {
  unsigned long micro = micros();

  tft.setWindow(x, y, x + width - 1, y + height - 1);
  uint16_t  writeBuffer[64];   
  uint16_t  iconArraySize = (width * height) / 2;
  uint8_t   bufferIdx = 0;
  
  for (int i = 0; i < iconArraySize; i++) {
    writeBuffer[bufferIdx] = colorPalette[icon[i] >> 4];
    bufferIdx++;
    writeBuffer[bufferIdx] = colorPalette[icon[i] & 0x0F];
    bufferIdx++;

    if (bufferIdx == 64){
      tft.pushColors(writeBuffer, 64);
      bufferIdx = 0;
    }
  }

  if (bufferIdx != 0){
    tft.pushColors(writeBuffer, bufferIdx);
  }
 
 Serial.println(micros()-micro);   
}


void drawIcon4Fast(const uint8_t icon[], int16_t x, int16_t y, uint16_t width, uint16_t height, uint16_t fgColor, uint16_t bgColor ) {
  unsigned long micro = micros();   

  uint16_t fgR = ((fgColor >> 10) & 0x3E) + 1;
  uint16_t fgG = ((fgColor >>  4) & 0x7E) + 1;
  uint16_t fgB = ((fgColor <<  1) & 0x3E) + 1;

  uint16_t bgR = ((bgColor >> 10) & 0x3E) + 1;
  uint16_t bgG = ((bgColor >>  4) & 0x7E) + 1;
  uint16_t bgB = ((bgColor <<  1) & 0x3E) + 1;

  tft.setWindow(x, y, x + width - 1, y + height - 1);

  uint8_t alpha;

  uint16_t  pix_buffer[64];   
  uint16_t  nb = (width * height) / 64;
 
  for (int i = 0; i < nb; i++) {
    for (int j = 0; j < 32; j++) {
      for (int8_t step = 0; step < 2; step++){
        if(step == 0){
          alpha = icon[i * 32 + j] & 0xF0;
        }
        else{
          alpha = icon[i * 32 + j]<<4;
        }
        switch(alpha){
          case 0:
            pix_buffer[(j*2)+step] = bgColor;
            break;
          case 240:
            pix_buffer[(j*2)+step] = fgColor;
            break;
          default:
            uint16_t r = (((fgR * alpha) + (bgR * (255 - alpha))) >> 9);
            uint16_t g = (((fgG * alpha) + (bgG * (255 - alpha))) >> 9);
            uint16_t b = (((fgB * alpha) + (bgB * (255 - alpha))) >> 9);
            pix_buffer[(j*2)+step] = (r << 11) | (g << 5) | (b << 0); 
        }  
      }
    }
    tft.pushColors(pix_buffer, 64);   
  }



  
  Serial.println(micros()-micro);  
}


uint16_t alphaBlend(uint8_t alpha, uint16_t fgc, uint16_t bgc)
{
  // For speed use fixed point maths and rounding to permit a power of 2 division
  uint16_t fgR = ((fgc >> 10) & 0x3E) + 1;
  uint16_t fgG = ((fgc >>  4) & 0x7E) + 1;
  uint16_t fgB = ((fgc <<  1) & 0x3E) + 1;

  uint16_t bgR = ((bgc >> 10) & 0x3E) + 1;
  uint16_t bgG = ((bgc >>  4) & 0x7E) + 1;
  uint16_t bgB = ((bgc <<  1) & 0x3E) + 1;

  // Shift right 1 to drop rounding bit and shift right 8 to divide by 256
  uint16_t r = (((fgR * alpha) + (bgR * (255 - alpha))) >> 9);
  uint16_t g = (((fgG * alpha) + (bgG * (255 - alpha))) >> 9);
  uint16_t b = (((fgB * alpha) + (bgB * (255 - alpha))) >> 9);

  // Combine RGB565 colours into 16 bits
  //return ((r&0x18) << 11) | ((g&0x30) << 5) | ((b&0x18) << 0); // 2 bit greyscale
  //return ((r&0x1E) << 11) | ((g&0x3C) << 5) | ((b&0x1E) << 0); // 4 bit greyscale
  return (r << 11) | (g << 5) | (b << 0);
}
